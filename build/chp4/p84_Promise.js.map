{"version":3,"sources":["../../chp4/p84_Promise.js"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;IAUM,O;;;AACF,uBAAc;AAAA;;AAAA;AAEb;;;;6BAEI,gB,EAAkB,Y,EAAc,e,EAAiB;AAClD,gBAAI,OAAO,gBAAP,KAA4B,UAAhC,EAA4C;AACxC,qBAAK,IAAL,CAAU,SAAV,EAAqB,gBAArB;AACH;AACD,gBAAI,OAAQ,YAAR,KAAyB,UAA7B,EAAyC;AACrC,qBAAK,IAAL,CAAU,OAAV,EAAmB,YAAnB;AACH;AACD,gBAAI,OAAO,eAAP,KAA2B,UAA/B,EAA2C;AACvC,qBAAK,EAAL,CAAQ,UAAR,EAAoB,eAApB;AACH;;AAED,mBAAO,IAAP;AACH;;;;EAjBiB,iBAAO,Y;;;;;;;;IAwBvB,Q;AACF,wBAAc;AAAA;;AACV,aAAK,KAAL,GAAa,aAAb;AACA,aAAK,OAAL,GAAe,IAAI,OAAJ,EAAf;AACH;;;;gCAEO,G,EAAK;AACT,iBAAK,KAAL,GAAa,WAAb;AACA,iBAAK,OAAL,CAAa,IAAb,CAAkB,SAAlB,EAA6B,GAA7B;AACH;;;+BAEM,G,EAAK;AACR,iBAAK,KAAL,GAAa,QAAb;AACA,iBAAK,OAAL,CAAa,IAAb,CAAkB,OAAlB,EAA2B,GAA3B;AACH;;;iCAEQ,I,EAAM;AACX,iBAAK,OAAL,CAAa,IAAb,CAAkB,UAAlB,EAA8B,IAA9B;AACH;;;;;;AAGL,IAAI,YAAY,SAAZ,SAAY,CAAU,GAAV,EAAe;AAC3B;;AACA,QAAI,WAAW,IAAI,QAAJ,EAAf;AACA,QAAI,SAAS,EAAb;AACA,QAAI,EAAJ,CAAO,MAAP,EAAe,UAAU,KAAV,EAAiB;AAC5B,kBAAU,KAAV;AACA,iBAAS,QAAT,CAAkB,KAAlB;AACH,KAHD;AAIA,QAAI,EAAJ,CAAO,KAAP,EAAc,YAAW;AACrB,iBAAS,OAAT,CAAiB,MAAjB;AACH,KAFD;AAGA,QAAI,EAAJ,CAAO,OAAP,EAAgB,UAAU,GAAV,EAAe;AAC3B,iBAAS,MAAT,CAAgB,GAAhB;AACH,KAFD;AAGA,WAAO,SAAS,OAAhB;AACH,CAfD;;;AAmBA,UAAU,GAAV,EAAe,IAAf,CAAoB,YAAY;;AAE/B,CAFD,EAEG,UAAS,GAAT,EAAc;;AAEhB,CAJD,EAIG,UAAS,KAAT,EAAgB;;AAEf,YAAQ,GAAR,CAAY,WAAW,KAAvB;AACH,CAPD","file":"p84_Promise.js","sourcesContent":["import events from 'events'\n\n/**\n * Promise/A提案\n * - 接受完成态, 错误态的回调方法, 在完成操作或者出现错误,将会调用相应方法\n * - 可选地支持progreee事件回调作为第三个方法\n * - then()方法只接受function对象, 其余对象将被忽略\n * - then()方法继续返回Promise对象, 实现链式调用\n * */\n\nclass Promise extends events.EventEmitter {\n    constructor() {\n        super();\n    }\n\n    then(fulfilledHandler, errorHandler, progressHandler) {\n        if (typeof fulfilledHandler === 'function') {\n            this.once('success', fulfilledHandler);\n        }\n        if (typeof  errorHandler === 'function') {\n            this.once('error', errorHandler);\n        }\n        if (typeof progressHandler === 'function') {\n            this.on('progress', progressHandler);\n        }\n\n        return this;\n    }\n}\n\n/**\n * 触发Promise中的回调方法\n *\n * */\nclass Deffered {\n    constructor() {\n        this.state = 'unfulfilled';\n        this.promise = new Promise();\n    }\n\n    resolve(obj) {\n        this.state = 'fulfilled';\n        this.promise.emit('success', obj);\n    }\n\n    reject(err) {\n        this.state = 'failed';\n        this.promise.emit('error', err);\n    }\n\n    progress(data) {\n        this.promise.emit('progress', data);\n    }\n}\n\nlet promisify = function (res) {\n    \"use strict\";\n    let deffered = new Deffered();\n    let result = '';\n    res.on('data', function (chunk) {\n        result += chunk;\n        deffered.progress(chunk);\n    });\n    res.on('end', function() {\n        deffered.resolve(result);\n    });\n    res.on('error', function (err) {\n        deffered.reject(err);\n    });\n    return deffered.promise;\n};\n\n\n// 调用\npromisify(res).then(function () {\n    // sucess handler\n}, function(err) {\n    // err handler\n}, function(chunk) {\n    // progress handler\n    console.log('BODY: ' + chunk);\n});"]}